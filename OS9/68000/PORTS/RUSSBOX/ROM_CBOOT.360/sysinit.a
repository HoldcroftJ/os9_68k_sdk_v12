 nam System Initialize
 ttl Hardware dependant routines for M68360

********************************
* SysInit and related hardware dependent routines
*
* Copyright 1993, 1994 by Microware Systems Corporation
* All Rights Reserved
* Reproduced Under License
*
*   This source code is the proprietary confidential property of
* Microware Systems Corporation, and is provided to the licensee
* for documentation and educational purposes only.  Reproduction,
* publication, or any form of distribution to any party other than
* the licensee is strictly prohibited.


********************************
*     Edition History
*
*  #   date   Comments                                          by
* -- -------- ------------------------------------------------- ---
* 00 10/05/93 intial											arb
* 01 94/06/01 updated for MWOS.									wwb
*				---- OS-9/68K V3.0.1 Release ----
*
Edition equ 1 current edition number

 use defsfile

********************
* Debugger usage
*
 ifdef DEBUGGER
USING_DEBUGGER set 1 define primitive debugger in use
 endc

 ifdef ROMBUG
USING_DEBUGGER set 1 define smart debugger in use
 endc

 psect sysinit,0,0,Edition,0,0

 use <rompak.m>

Auto7vector equ 31*4 auto-level 7 vector offset

********************
* SysInit:  perform system specific initialization (part 1)
*
SysInit:

*  Set the base address for the mc68360 on-board modules
*

 	move.l #FC_SCPU,d0         set function code for CPU space
 	movec d0,DFC
 	movec d0,SFC
 	move.l	 #DPRBASE,d0
	move.l	d0,a5			a5 points to master quicc
	ori.l	#1,d0			set address valid bit
 	moves.l d0,MBAR            set in the module base address

	move.b	RSR(a5),d0	; get a copy of RSR
	move.b	#$ff,RSR(a5)	; clear RSR so that it will be correct after
* This sets CS0 to point to a 128K ROM bank from $000000-$0001FFFF with
* 4 wait states
	move.l	#$00002200,GMR(a5)	; QUADS board specific values.
*								; 15.36 microsec DRAM refresh per.
*								; 3 clock refresh cycle length
*								; 32 bit port size
*								; parity disabled
*								; CS/RAS of slave will not assert
*								;  when writing CPU space
*								; Internal address MUXing disabled
*								;  See 
*								; section 9.1 and section 6.13.1 for
*								; advice on how to set yours up.
	move.l	#$5ffe0004,OR0(a5)	; SRAM Bank, 8 bits wide, disabled 
*								; page mode Burst Cycle length 1,
*								; Ignore function codes, 128K bank
*								; size, TCYC=5 --> 4 wait states
	move.l	#$00000003,BR0(a5)	; Valid, Read Only, No Parity, Normal
*								; CS* negation for both 030 & 040
*								; Bus Masters No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00000000

	ori.w	#$4000,PLLCR(a5)	; using a 25 MHz oscillator 
*					; (QUADS board), set the PLLWR bit
*					; to prevent further writes
	move.b	#$ab,CLKOCR(a5)		; Write Protect On, PLL Loss of Lock
	ori.w	#$8000,CDVCR(a5)	; Not using the low power clock 
*					; divider. Write Protect the register
	move.w	#$0200,PITR(a5)	; To Prescale the SWT clock by 512 (Used
    move.b  #$37,SYPCR(a5)  ; Same as above but watchdog is off
	move.l	#$00007cff,MCR(a5)	; Async Bus Timing, Async Arbitration
	move.w	#$8001,CR(a5)	; CPM Reset Command reinitializes Dual
*							; Port RAM

*** Step 10 - Write the PEPAR
*
	move.w	#$0020,PEPAR(a5)	; Will vary depending on your 
*								; specific hardware design.  This is
*								; the value for the
*								; Master QUICC on the QUADS board.
		
*** Step 11x - Initialize the Slave QUICC
* On the QUADS board, all of the memory banks except for the boot EPROM are
* controlled from the slave QUICC.  Thus the slave QUICC must be set up
* before Step 12 - Initialize System RAM can take place.  This section is
* an example of setting up a Slave QUICC.

	move.b	#$80,AVR(a5)	; Initialize MASTER QUICC to generate 
*							; autovector for interrupt level 7
*							; This differs from Section 3.4.3 of the
*							; QUADS User's Manual which is incorrect.
*							; The MASTER QUICC should never generate
*							; autovectors for interrupts generated by
*							; the SLAVE (except level 7).

*** Write Slave MBAR
	move.l	#7,d0			; "0111" is the function code for CPU Space
	movec	d0,SFC			; Store "0111" into both the Src Fcn Code Reg
	movec	d0,DFC			; and the Dest. Fcn Code Reg
    move.l  #$bfffffff,d0
    moves.l d0,SMBARE       ; Pull D30 low to assert MBARE* on
	move.l	#SBARSET+1,d0	; Base = $22000, valid bit set, no masking
*							; Slave and place a 1 in the MBAR
*							; select bit to allow a write to
*							; MBAR on the slave. (This statement
*							; assumes a 32-bit data bus. See
*							; Section 3.5.1 of the QUADS Manual
*							; for 16-bit Bus information)
	moves.l	d0,SMBAR		; Set Slave MBAR
	move.l	#SBARSET,a4      ; Move it to a4 for slave reg indexing
	
*** Deal with the Slave Clock Synthesizer
	ori.w	#$4000,PLLCR(a4)	; If using a 25 MHz oscillator 
*								; (QUADS board), set the PLLWR bit
*								; to prevent further writes
	move.b	#$af,CLKOCR(a4)		; Write Protect On, PLL Loss of Lock
*								; condition causes reset, COM
*								; settings are for QUADS board
*								; SLAVE QUICC.  Your hardware may
*								; differ.
	ori.w	#$8000,CDVCR(a4)	; Not using the low power clock 
*								; divider. Write Protect the register

*** Initialize the Slave System Protection
	move.w	#$0200,PITR(a4)		; To Prescale the SWT clock by 512 (Used
*								; with SYPCR to obtain the Timout values 
*								; in Table 6-4)
    move.b  #$37,SYPCR(a4)  	; Same as above but leave watchdog off
	move.w	#$8001,CR(a4)		; CPM Reset Command reinitializes Dual
*								; Port RAM in SLAVE
	
*** Write the Slave PEPAR
* Ordinarily, this would be done here.  Due to QUADS hardware, it must 
* be done after CS6 is set up.

* This sets CS4 to point to a 16 bit register that repeats over a bank
* from $00024000-$00025FFF 
	move.l	#$0fffe002,OR4(a4)	; EPROM Bank, 16 bits wide, disabled 
*								; page mode, Burst Cycle length 1,
*								; Ignore function codes, 8K bank
*								; size, TCYC=0 --> Fast Termination
	move.l	#$00024003,BR4(a4)	; Valid, Read Only, No Parity, Early 
*								; CS* negation for 030 master but
*								; normal negation for 040 master,
*								; No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00024000

*****************************************************
*
*	now find out what kind of dram module there is
	move.l	#$24000,a0
	move.w	(a0),d0	
	lsr.w	#4,d0
	andi.l	#$0000000f,d0			d0 now equals dram module type
	lea		dramtbl(pc),a0

*** Remap Slave Chip Select 0 
	move.l	(a0,d0*8),GMR(a4)	; QUADS board specific values.  See 
*								; section 9.1 and section 6.13.1 for
*								; advice on how to set yours up.
	move.l	#$fffe0006,OR0(a4)	; QUADS board specific values
	move.l	#$00000003,BR0(a4)	; QUADS board specific values


*** Initialize All Other Memory and Peripherals
* This sets CS1 to point to a 1 Meg RAM bank from $00400000-$004FFFFF with
* 1 wait state
	move.l	4(a0,d0*8),OR1(a4)	; RAM Bank, 32 bits wide, enabled 
*								; page mode, Burst Cycle length 1,
*								; Ignore function codes, 1 Meg bank
*								; size, TCYC=2 --> 1 wait state
	move.l	#$00400005,BR1(a4)	; Valid, Read/WRite, Parity, Normal
*								; CS* negation for both 030 & 040
*								; Bus Masters, No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00400000

* CS2 not used on QUADS board with 1 Meg of DRAM
* This sets CS2
	move.l	4(a0,d0*8),OR2(a4)	; RAM Bank, 32 bits wide, enabled 
*								; page mode, Burst Cycle length 1,
*								; Ignore function codes, 1 Meg bank
*								; size, TCYC=2 --> 1 wait state
	move.l	#$00400005,BR2(a4)	; Valid, Read/WRite, Parity, Normal
*								; CS* negation for both 030 & 040
*								; Bus Masters, No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00400000

* This sets CS3 to point to a 512K Flash RAM bank from $00080000-$000FFFFF
* with 2 wait states
	move.l	#$3ff80000,OR3(a4)	; SRAM Bank, 32 bits wide, disabled 
*								; page mode, Burst Cycle length 1,
*								; Ignore function codes, 1 Meg bank
*								; size, TCYC=3 --> 2 wait states
	move.l	#$00080009,BR3(a4)	; Valid, Read Only, No Parity, Early 
*								; CS* negation for 030 master but
*								; normal negation for 040 master,
*								; No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00080000
* This sets CS5 to point to a 8 bit register that repeats over a bank
* from $00026000-$00027FFF 
	move.l	#$0fffe004,OR5(a4)	; SRAM Bank, 8 bits wide, disabled 
*								; page mode, Burst Cycle length 1,
*								; Ignore function codes, 8K bank
*								; size, TCYC=0 --> Fast Termination
	move.l	#$00026001,BR5(a4)	; Valid, Read Only, No Parity, Normal 
*								; CS* negation for 030  and 040
*								; Bus Masters,
*								; No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00026000
* This sets CS6 to point to a 8 bit register that repeats over a bank
* from $00028000-$00029FFF 
	move.l	#$0fffe004,OR6(a4)	; SRAM Bank, 8 bits wide, disabled 
*								; page mode, Burst Cycle length 1,
*								; Ignore function codes, 8K bank
*								; size, TCYC=0 --> Fast Termination
	move.l	#$00028001,BR6(a4)	; Valid, Read Only, No Parity, Normal 
*								; CS* negation for 030  and 040
*								; Bus Masters,
*								; No burst ack, do not
*								; relax timing, FC=0000
*								; Base Address = $00028000
	move.l	#$f0000006,OR7(a4)	; QUADS board specific values
	move.l	#$00000001,BR7(a4)	; QUADS board specific values
*
*

*** Write Slave PEPAR
* QUADS Specific Code
	lea	$00026000,a0			; get address of NMI Status Reg
	move.w	#$0000,(a0)			; To clear the NMI Status Register
*								; on the QUADS board (MUST BE DONE
*								; BEFORE WRITING PEPAR)
	move.w	#$3760,PEPAR(a4)	; Will vary depending on your 
*								; specific hardware design.  This is
*								; the value for the
*								; SLAVE QUICC on the QUADS board.
    move.w	#$0303,PAPAR(a4)
 	move.w	#$ffff,PADAT(a4)
	move.w	#$3c20,PADIR(a4)
	move.w	#$30d,PAODR(a4)
	clr.w	PBODR(a4)
	move.l #$3ffff,PBDAT(a4)
	move.l	#$7f,PBDIR(a4)
	move.l	#$e,PBPAR(a4)
	move.w	#$0,PCDIR(a4)
	move.w	#$0,PCPAR(a4)
	move.w	#$0030,PCSO(a4)		port c CTS1 and CD1
 	move.l	#$2c,SICR(a4)
	move.w	#$0740,SDCR(a4)
    move.l	#$00e4bfe0,CICR(a4)	; setup cpm Interrupt config register
*								; we will use irqs $e0-$ff
***
* Further Setup of the Slave QUICC on the QUADS board can be found in 
* section 3.5 of the QUADS Board User's Manual
***
*   must do 8 access to start dram
	move.l	#$400000,a0
	moveq.l	#7,d1
dram.l move.l (a0),d0
	dbf d1,dram.l
*** Step 12 - Initialize System RAM
* 
* This assumes that 100 usec. have elapsed between cs1* being set up
* and this code executing..

*** Step 13 - Copy the EVT to System RAM
	move.l	#VBRBase,a0
	movec	a0,vbr
*       This ram must be sufficiant in size for OS-9 to place a vector
*       table, stack and system globals.
*
 move.l VectTbl(pc),0(a0) initialize reset SSP...
 move.l VectTbl+4(pc),4(a0) ...and PC

** locate and execute extention code
**     Note: MUST have RAM enabled for the stack before this is done!!!

 ROMPAK1

 bra SysRetrn return to boot.a

*   		GMR		OR1/OR2
dramtbl:  
	dc.l $17a44380,$3fc00009
	dc.l $0aa44380,$3ff00009
	dc.l $17a44380,$3ff00009
	dc.l $0aa44380,$3fc00009
	dc.l $17a40380,$2fc00009
	dc.l $0aa40380,$2ff00009
	dc.l $17a40380,$2ff00009
	dc.l $0aa40380,$2fc00009
	dc.l $17840380,$2fc00009
	dc.l $0a840380,$2ff00009
	dc.l $17840380,$2ff00009
	dc.l $0a840380,$2fc00009
********************
* SInitTwo:  perform system specific initialization (part 2)
*

SInitTwo:
 ifdef USING_DEBUGGER
 movem.l a0-a1,-(sp) save regs
 movec vbr,a0 get vbr
* setup handler for abort switch
 lea.l AbortHdlr(pc),a1 get address of handler
 move.l a1,Auto7vector(a0) abort switch calls our handler
 movem.l (sp)+,a0-a1 restore regs
 endc USING_DEBUGGER

* Run additional setup that may or may not be in the extension module
 ROMPAK2
 rts

********************
* UseDebug:  signal whether debugger is enabled or not
*
* Due to the lack of a hardware switch, a rom location flag
* is tested.  This flag is defined in "boot.a".
*
* Returns:  CCR Z Flag = TRUE (rom debugger disabled)
*                      = FALSE (rom debugger enabled)
*
UseDebug:
 move.l Sys_Switches(pc),d0
 andi.b #DebugSwitch,d0
 rts

*
* routine to return switch values ( used by getbootmethod() [see syscon.c])
readswitches:
 move.l Sys_Switches(pc),d0
  rts

get_enet_addr:
	move.l	a0,-(sp)
 	lea 	enet_addr(pc),a0		get address of ethernet address in rom
	move.l	a0,d0
	move.l	(sp)+,a0
	rts
********************
* Abort Switch Handler
*
 ifdef USING_DEBUGGER
* This routine clears down the abort switch interrupt.
* If the primitive debugger is in use, then it is entered as
* if an autolevel 7 irq had occurred.
* If the smart debugger is in use, then execution resumes at
* the jump table entry for ABORTVECT
*
AbortHdlr:
 move.w	#$ffff,$26000			ack NMI
 lea.l -10(sp),sp carve some stack space
 move.w sr,4(sp) save CCR status
 move.l a0,0(sp) save a0
 lea	Aut7Trap(pc),a0
 move.l	a0,6(sp)			continue at auto 7 handler
 movea.l (sp)+,a0 restore a0
 rtr enter debugger
 endc USING_DEBUGGER


*  He who is responsible for this excursion.....
*
PortMan: dc.b "Portman: Allan R. Batteiger",0,0

 ends
